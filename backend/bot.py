"""Scrabble bot based on a Trie and move generation with cross checks.

This module implements a simple Scrabble AI inspired by the reference
implementation provided by the user.  Words are stored in a Trie, moves are
generated by scanning anchor squares on the board and all candidates are scored
with basic letter values.  The public helpers ``bot_turn`` and
``is_valid_placement`` keep the same signature as the previous implementation so
existing callers and tests continue to work.
"""

from dataclasses import dataclass
from typing import Dict, List, Optional, Set, Tuple

from . import game

# ---------------------------------------------------------------------------
# Constants and helpers
# ---------------------------------------------------------------------------

BOARD_SIZE = game.BOARD_SIZE
ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"


class TrieNode:
    __slots__ = ("children", "is_word")

    def __init__(self) -> None:
        self.children: Dict[str, "TrieNode"] = {}
        self.is_word: bool = False


class Trie:
    def __init__(self) -> None:
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for ch in word:
            node = node.children.setdefault(ch, TrieNode())
        node.is_word = True

    def has_word(self, word: str) -> bool:
        node = self.root
        for ch in word:
            node = node.children.get(ch)
            if node is None:
                return False
        return node.is_word

    def step(self, node: TrieNode, ch: str) -> Optional[TrieNode]:
        return node.children.get(ch)


@dataclass
class Cell:
    letter: Optional[str] = None
    letter_mult: int = 1
    word_mult: int = 1
    is_center: bool = False


@dataclass
class Move:
    row: int
    col: int
    vertical: bool
    letters: List[Tuple[int, int, str, bool]]  # (r, c, letter, is_blank)
    main_word: str
    score: int


class Board:
    """Simple board representation holding :class:`Cell` objects."""

    def __init__(self, cells: Optional[List[List[Cell]]] = None) -> None:
        if cells is None:
            self.cells = [
                [Cell() for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)
            ]
            self.cells[7][7].is_center = True
        else:
            self.cells = cells

    def get(self, r: int, c: int) -> Cell:
        return self.cells[r][c]

    def in_bounds(self, r: int, c: int) -> bool:
        return 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE

    def row_as_cells(self, r: int) -> List[Cell]:
        return self.cells[r]

    def transpose(self) -> "Board":
        T = [[self.cells[r][c] for r in range(BOARD_SIZE)] for c in range(BOARD_SIZE)]
        return Board(T)

    def has_any_letter(self) -> bool:
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                if self.cells[r][c].letter:
                    return True
        return False


# Basic letter scores â€“ not the full French Scrabble values but adequate for
# testing and move selection.
LETTER_SCORES: Dict[str, int] = {
    **{ch: 1 for ch in "EAIONRTLSU"},
    **{ch: 2 for ch in "DG"},
    **{ch: 3 for ch in "BCMP"},
    **{ch: 4 for ch in "FHVWY"},
    "K": 5,
    **{ch: 8 for ch in "JX"},
    **{ch: 10 for ch in "QZ"},
}


def letters_available(rack: Dict[str, int]) -> Set[str]:
    letters = {ch for ch, n in rack.items() if ch != "?" and n > 0}
    if rack.get("?", 0) > 0:
        letters |= set(ALPHABET)
    return letters


def remove_letter(rack: Dict[str, int], ch: str) -> Tuple[Dict[str, int], bool]:
    new_rack = dict(rack)
    if new_rack.get(ch, 0) > 0:
        new_rack[ch] -= 1
        return new_rack, False
    if new_rack.get("?", 0) > 0:
        new_rack["?"] -= 1
        return new_rack, True
    raise ValueError("Letter not available in rack")


def build_full_horizontal(board: Board, r: int, c: int, ch_mid: str) -> str:
    cc = c - 1
    while board.in_bounds(r, cc) and board.get(r, cc).letter:
        cc -= 1
    cc += 1
    letters: List[str] = []
    while board.in_bounds(r, cc):
        if cc == c:
            letters.append(ch_mid)
        elif board.get(r, cc).letter:
            letters.append(board.get(r, cc).letter)
        else:
            if cc > c:
                break
        cc += 1
    return "".join(letters)


def build_full_vertical(board: Board, r: int, c: int, ch_mid: str) -> str:
    rr = r - 1
    while board.in_bounds(rr, c) and board.get(rr, c).letter:
        rr -= 1
    rr += 1
    letters: List[str] = []
    while board.in_bounds(rr, c):
        if rr == r:
            letters.append(ch_mid)
        elif board.get(rr, c).letter:
            letters.append(board.get(rr, c).letter)
        else:
            if rr > r:
                break
        rr += 1
    return "".join(letters)


def compute_cross_checks(
    board: Board, trie: Trie, vertical_scan: bool
) -> List[List[Set[str]]]:
    cross: List[List[Set[str]]] = [
        [set(ALPHABET) for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)
    ]
    for r in range(BOARD_SIZE):
        for c in range(BOARD_SIZE):
            if board.get(r, c).letter:
                cross[r][c] = set()
                continue
            if vertical_scan is False:
                if (board.in_bounds(r - 1, c) and board.get(r - 1, c).letter) or (
                    board.in_bounds(r + 1, c) and board.get(r + 1, c).letter
                ):
                    allowed: Set[str] = set()
                    for ch in ALPHABET:
                        word = build_full_vertical(board, r, c, ch)
                        if len(word) == 1 or trie.has_word(word):
                            allowed.add(ch)
                    cross[r][c] = allowed
            else:
                if (board.in_bounds(r, c - 1) and board.get(r, c - 1).letter) or (
                    board.in_bounds(r, c + 1) and board.get(r, c + 1).letter
                ):
                    allowed = set()
                    for ch in ALPHABET:
                        word = build_full_horizontal(board, r, c, ch)
                        if len(word) == 1 or trie.has_word(word):
                            allowed.add(ch)
                    cross[r][c] = allowed
    return cross


def find_anchors_in_row(
    board: Board, r: int, first_move: bool
) -> List[Tuple[int, int]]:
    anchors: List[Tuple[int, int]] = []
    row = board.row_as_cells(r)
    for c in range(BOARD_SIZE):
        if row[c].letter:
            continue
        is_anchor = False
        if first_move and row[c].is_center:
            is_anchor = True
        else:
            if (
                (c > 0 and row[c - 1].letter)
                or (c < BOARD_SIZE - 1 and row[c + 1].letter)
                or (r > 0 and board.get(r - 1, c).letter)
                or (r < BOARD_SIZE - 1 and board.get(r + 1, c).letter)
            ):
                is_anchor = True
        if is_anchor:
            left = 0
            cc = c - 1
            while cc >= 0 and not row[cc].letter:
                left += 1
                cc -= 1
            anchors.append((c, left))
    return anchors


def score_move(board: Board, move: Move) -> int:
    total = 0
    r0, c0 = move.row, move.col
    vertical = move.vertical
    letters_used_positions = {(r, c) for (r, c, _, _) in move.letters}

    if not vertical:  # horizontal main word
        cc = c0
        while cc > 0 and board.get(r0, cc - 1).letter:
            cc -= 1
        word_mult = 1
        word_score = 0
        while cc < BOARD_SIZE and (
            board.get(r0, cc).letter or (r0, cc) in letters_used_positions
        ):
            if (r0, cc) in letters_used_positions:
                ch = next(x[2] for x in move.letters if x[0] == r0 and x[1] == cc)
                is_blank = next(x[3] for x in move.letters if x[0] == r0 and x[1] == cc)
                letter_value = 0 if is_blank else LETTER_SCORES.get(ch, 0)
                letter_mult = board.get(r0, cc).letter_mult
                word_mult *= board.get(r0, cc).word_mult
                word_score += letter_value * letter_mult
            else:
                ch = board.get(r0, cc).letter
                word_score += LETTER_SCORES.get(ch, 0)
            cc += 1
        total += word_score * word_mult

        for rr, cc, ch, is_blank in move.letters:
            up = rr - 1
            down = rr + 1
            if (board.in_bounds(up, cc) and board.get(up, cc).letter) or (
                board.in_bounds(down, cc) and board.get(down, cc).letter
            ):
                r_up = rr
                while r_up > 0 and board.get(r_up - 1, cc).letter:
                    r_up -= 1
                word_mult = board.get(rr, cc).word_mult
                word_score = (0 if is_blank else LETTER_SCORES.get(ch, 0)) * board.get(
                    rr, cc
                ).letter_mult
                r_scan = r_up
                while r_scan < BOARD_SIZE and (
                    r_scan == rr or board.get(r_scan, cc).letter
                ):
                    if r_scan != rr:
                        ch2 = board.get(r_scan, cc).letter
                        word_score += LETTER_SCORES.get(ch2, 0)
                    r_scan += 1
                total += word_score * word_mult
    else:  # vertical main word
        rr = r0
        while rr > 0 and board.get(rr - 1, c0).letter:
            rr -= 1
        word_mult = 1
        word_score = 0
        while rr < BOARD_SIZE and (
            board.get(rr, c0).letter or (rr, c0) in letters_used_positions
        ):
            if (rr, c0) in letters_used_positions:
                ch = next(x[2] for x in move.letters if x[0] == rr and x[1] == c0)
                is_blank = next(x[3] for x in move.letters if x[0] == rr and x[1] == c0)
                letter_value = 0 if is_blank else LETTER_SCORES.get(ch, 0)
                letter_mult = board.get(rr, c0).letter_mult
                word_mult *= board.get(rr, c0).word_mult
                word_score += letter_value * letter_mult
            else:
                ch = board.get(rr, c0).letter
                word_score += LETTER_SCORES.get(ch, 0)
            rr += 1
        total += word_score * word_mult

        for rr, cc, ch, is_blank in move.letters:
            left = cc - 1
            right = cc + 1
            if (board.in_bounds(rr, left) and board.get(rr, left).letter) or (
                board.in_bounds(rr, right) and board.get(rr, right).letter
            ):
                c_left = cc
                while c_left > 0 and board.get(rr, c_left - 1).letter:
                    c_left -= 1
                word_mult = board.get(rr, cc).word_mult
                word_score = (0 if is_blank else LETTER_SCORES.get(ch, 0)) * board.get(
                    rr, cc
                ).letter_mult
                c_scan = c_left
                while c_scan < BOARD_SIZE and (
                    c_scan == cc or board.get(rr, c_scan).letter
                ):
                    if c_scan != cc:
                        ch2 = board.get(rr, c_scan).letter
                        word_score += LETTER_SCORES.get(ch2, 0)
                    c_scan += 1
                total += word_score * word_mult

    if len(move.letters) == 7:
        total += 50
    return total


def build_move_from_state(
    board: Board,
    row: int,
    anchor_col: int,
    placed: List[Tuple[int, int, str, bool]],
    vertical: bool,
    trie: Trie,
) -> Optional[Move]:
    if not placed:
        return None
    if (row, anchor_col) not in {(r, c) for (r, c, _, _) in placed} and not board.get(
        row, anchor_col
    ).letter:
        return None
    tmp_board = Board(
        [
            [Cell(letter=board.get(r, c).letter) for c in range(BOARD_SIZE)]
            for r in range(BOARD_SIZE)
        ]
    )
    for r, c, ch, _ in placed:
        tmp_board.get(r, c).letter = ch
    if not vertical:
        c = min(c for (r, c, _, _) in placed if r == row)
        while c > 0 and tmp_board.get(row, c - 1).letter:
            c -= 1
        letters: List[str] = []
        cc = c
        used = {(r, c) for (r, c, _, _) in placed}
        while cc < BOARD_SIZE and (tmp_board.get(row, cc).letter or (row, cc) in used):
            letters.append(tmp_board.get(row, cc).letter)
            cc += 1
        main_word = "".join(letters)
    else:
        r = min(r for (r, c, _, _) in placed if c == anchor_col)
        while r > 0 and tmp_board.get(r - 1, anchor_col).letter:
            r -= 1
        letters = []
        rr = r
        used = {(r, c) for (r, c, _, _) in placed}
        while rr < BOARD_SIZE and (
            tmp_board.get(rr, anchor_col).letter or (rr, anchor_col) in used
        ):
            letters.append(tmp_board.get(rr, anchor_col).letter)
            rr += 1
        main_word = "".join(letters)
    if not trie.has_word(main_word):
        return None
    mv = Move(
        row=row,
        col=anchor_col,
        vertical=vertical,
        letters=placed.copy(),
        main_word=main_word,
        score=0,
    )
    mv.score = score_move(board, mv)
    return mv


def dfs_left(
    board: Board,
    trie: Trie,
    rack: Dict[str, int],
    row: int,
    anchor_col: int,
    left_rest: int,
    cross: List[List[Set[str]]],
    moves: List[Move],
    vertical: bool,
):
    def extend_left(
        node: TrieNode,
        col: int,
        left_left: int,
        placed: List[Tuple[int, int, str, bool]],
        used_from_rack: bool,
    ) -> None:
        extend_right(node, anchor_col, placed, used_from_rack)
        if left_left == 0:
            return
        next_col = col - 1
        if next_col < 0:
            return
        cell = board.get(row, next_col)
        if cell.letter:
            node2 = trie.step(node, cell.letter)
            if node2:
                # Existing letters to the left extend the prefix but do not
                # belong to the placement list since the bot does not place
                # tiles on already occupied cells.
                extend_left(node2, next_col, left_left - 1, placed, used_from_rack)
            return
        for ch in letters_available(rack):
            if ch not in cross[row][next_col]:
                continue
            node2 = trie.step(node, ch)
            if not node2:
                continue
            try:
                new_rack, used_blank = remove_letter(rack, ch)
            except ValueError:
                continue
            old_rack = dict(rack)
            rack.clear()
            rack.update(new_rack)
            extend_left(
                node2,
                next_col,
                left_left - 1,
                [(row, next_col, ch, used_blank)] + placed,
                True,
            )
            rack.clear()
            rack.update(old_rack)

    def extend_right(
        node: TrieNode,
        col: int,
        placed: List[Tuple[int, int, str, bool]],
        used_from_rack: bool,
    ) -> None:
        c = col
        made_progress = False
        while c < BOARD_SIZE:
            cell = board.get(row, c)
            if cell.letter:
                node = trie.step(node, cell.letter)
                if not node:
                    return
                c += 1
                continue
            legal_here = False
            for ch in letters_available(rack):
                if ch not in cross[row][c]:
                    continue
                node2 = trie.step(node, ch)
                if not node2:
                    continue
                try:
                    new_rack, used_blank = remove_letter(rack, ch)
                except ValueError:
                    continue
                old_rack = dict(rack)
                rack.clear()
                rack.update(new_rack)
                placed.append((row, c, ch, used_blank))
                made_progress = True
                if node2.is_word and used_from_rack:
                    mv = build_move_from_state(
                        board, row, anchor_col, placed, vertical, trie
                    )
                    if mv:
                        moves.append(mv)
                extend_right(node2, c + 1, placed, True)
                placed.pop()
                rack.clear()
                rack.update(old_rack)
                legal_here = True
            break
        if not made_progress and node.is_word and used_from_rack:
            mv = build_move_from_state(board, row, anchor_col, placed, vertical, trie)
            if mv:
                moves.append(mv)

    extend_left(trie.root, anchor_col, left_rest, [], False)


def generate_moves(board: Board, rack: Dict[str, int], trie: Trie) -> List[Move]:
    moves: List[Move] = []
    first_move = not board.has_any_letter()
    cross_h = compute_cross_checks(board, trie, vertical_scan=False)
    for r in range(BOARD_SIZE):
        anchors = find_anchors_in_row(board, r, first_move)
        for anchor_col, left_limit in anchors:
            extra = 1 if anchor_col > 0 and board.get(r, anchor_col - 1).letter else 0
            dfs_left(
                board,
                trie,
                rack,
                r,
                anchor_col,
                left_limit + extra,
                cross_h,
                moves,
                vertical=False,
            )

    t_board = board.transpose()
    cross_v = compute_cross_checks(t_board, trie, vertical_scan=False)
    for r in range(BOARD_SIZE):
        anchors = find_anchors_in_row(t_board, r, first_move)
        for anchor_col, left_limit in anchors:
            tmp: List[Move] = []
            extra = 1 if anchor_col > 0 and t_board.get(r, anchor_col - 1).letter else 0
            dfs_left(
                t_board,
                trie,
                rack,
                r,
                anchor_col,
                left_limit + extra,
                cross_v,
                tmp,
                vertical=False,
            )
            for mv in tmp:
                new_letters = [
                    (c, r_, ch, is_blank) for (r_, c, ch, is_blank) in mv.letters
                ]
                moves.append(
                    Move(
                        row=mv.col,
                        col=mv.row,
                        vertical=True,
                        letters=new_letters,
                        main_word=mv.main_word,
                        score=mv.score,
                    )
                )
    for mv in moves:
        mv.score = score_move(board, mv)
    return moves


def best_move(board: Board, rack: Dict[str, int], trie: Trie) -> Optional[Move]:
    all_moves = generate_moves(board, rack, trie)
    if not all_moves:
        return None
    return max(all_moves, key=lambda m: m.score)


# ---------------------------------------------------------------------------
# Public helpers compatible with previous API
# ---------------------------------------------------------------------------

DICTIONARY: Set[str] = set(game.DICTIONARY)
DICTIONARY_BY_LENGTH: Dict[int, List[str]] = {}


def _rebuild_dicts() -> None:
    DICTIONARY_BY_LENGTH.clear()
    for w in DICTIONARY:
        DICTIONARY_BY_LENGTH.setdefault(len(w), []).append(w)


_rebuild_dicts()


def _build_trie() -> Trie:
    trie = Trie()
    for w in DICTIONARY:
        trie.insert(w.upper())
    return trie


def bot_turn(
    board: List[List[Optional[str]]], rack: List[str]
) -> Tuple[List[Tuple[int, int, str, bool]], int]:
    trie = _build_trie()
    board_obj = Board(
        [
            [Cell(letter=board[r][c]) for c in range(BOARD_SIZE)]
            for r in range(BOARD_SIZE)
        ]
    )
    rack_counts: Dict[str, int] = {}
    for ch in rack:
        rack_counts[ch.upper()] = rack_counts.get(ch.upper(), 0) + 1
    move = best_move(board_obj, rack_counts, trie)
    if move is None:
        return [], 0
    return move.letters, move.score


def is_valid_placement(
    board: List[List[Optional[str]]],
    word: str,
    row: int,
    col: int,
    direction: str,
) -> Tuple[bool, int, List[Tuple[int, int, str]]]:
    trie = _build_trie()
    board_before = Board(
        [
            [Cell(letter=board[r][c]) for c in range(BOARD_SIZE)]
            for r in range(BOARD_SIZE)
        ]
    )
    placements: List[Tuple[int, int, str, bool]] = []
    word = word.upper()
    for i, ch in enumerate(word):
        r = row + (i if direction == "down" else 0)
        c = col + (i if direction == "across" else 0)
        if not board_before.in_bounds(r, c):
            return False, 0, []
        cell = board_before.get(r, c)
        if cell.letter:
            if cell.letter != ch:
                return False, 0, []

        else:
            placements.append((r, c, ch, False))
    if not placements:
        return False, 0, []

    board_after = Board(
        [
            [Cell(letter=board[r][c]) for c in range(BOARD_SIZE)]
            for r in range(BOARD_SIZE)
        ]
    )
    for r, c, ch, _ in placements:
        board_after.get(r, c).letter = ch

    # first move must cover center
    if not board_before.has_any_letter():
        if not board_after.get(7, 7).letter:
            return False, 0, []
    else:

        connected = False
        for r, c, _, _ in placements:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                rr, cc = r + dr, c + dc
                if board_before.in_bounds(rr, cc) and board_before.get(rr, cc).letter:

                    connected = True
                    break
            if connected:
                break
        if not connected:
            return False, 0, []

    for r, c, ch, _ in placements:
        if direction == "across":
            word_cross = build_full_vertical(board_after, r, c, ch)
        else:
            word_cross = build_full_horizontal(board_after, r, c, ch)
        if len(word_cross) > 1 and not trie.has_word(word_cross):
            return False, 0, []

    if direction == "across":
        main_word = build_full_horizontal(
            board_after, row, col, board_after.get(row, col).letter
        )
    else:
        main_word = build_full_vertical(
            board_after, row, col, board_after.get(row, col).letter
        )
    if not trie.has_word(main_word):
        return False, 0, []

    move = Move(
        row=row,
        col=col,
        vertical=(direction == "down"),
        letters=placements,
        main_word=main_word,
        score=0,
    )
    score = score_move(board_before, move)
    placements_simple = [(r, c, ch) for (r, c, ch, _blank) in placements]
    return True, score, placements_simple


__all__ = ["bot_turn", "is_valid_placement", "BOARD_SIZE", "DICTIONARY"]
