<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Scrabble</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div id="app"></div>
  <script type="module">
    import * as Vue from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
    import { loadModule } from 'https://unpkg.com/vue3-sfc-loader/dist/vue3-sfc-loader.esm.js'
    // Chargement des modules avec gestion d'erreur
    let LETTER_POINTS, startAuthHeartbeat, stopAuthHeartbeat, runBotThinking, showInvalidWords, collectWords, API_BASE;

    try {
      const [
        letterPointsModule,
        authModule,
        botModule,
        invalidModule,
        validateModule,
        apiModule
      ] = await Promise.all([
        import('./letterPoints.js'),
        import('./authHeartbeat.js'),
        import('./botThinking.js'),
        import('./invalidWords.js'),
        import('./validateWords.js'),
        import('./api.js')
      ]);

      LETTER_POINTS = letterPointsModule.LETTER_POINTS;
      startAuthHeartbeat = authModule.startAuthHeartbeat;
      stopAuthHeartbeat = authModule.stopAuthHeartbeat;
      runBotThinking = botModule.runBotThinking;
      showInvalidWords = invalidModule.showInvalidWords;
      collectWords = validateModule.collectWords;
      API_BASE = apiModule.API_BASE;

      console.log('✅ Tous les modules Scrabble chargés avec succès');
      console.log('🌐 API_BASE configuré:', API_BASE);

    } catch (error) {
      console.error('❌ Erreur lors du chargement des modules:', error);
      // Configuration de fallback
      API_BASE = 'http://app-scrabble.tulip-saas.fr:8001';
      console.log('💡 Utilisation API_BASE de fallback:', API_BASE);
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible') {
        try {
          await fetch(`${API_BASE}/auth/refresh`, { method: 'POST', credentials: 'include' })
        } catch {
          // ignore
        }
      }
    })

    // const options = {
    //   moduleCache: { vue: Vue },
    //   async getFile(url) {
    //     const res = await fetch(url)
    //     if (!res.ok) throw Object.assign(new Error(res.statusText + ' ' + url), { res })
    //     return await res.text()
    //   },
    //   addStyle(textContent) {
    //     const style = Object.assign(document.createElement('style'), { textContent })
    //     const ref = document.head.getElementsByTagName('style')[0] || null
    //     document.head.insertBefore(style, ref)
    //   }
    // }

    const options = {
      moduleCache: {
        vue: Vue
      },
      async getFile(url) {
        const res = await fetch(url);
        if (!res.ok)
          throw Object.assign(new Error(res.statusText + ' ' + url), { res });
        return await res.text();
      },
      addStyle(textContent) {
        const style = Object.assign(document.createElement('style'), { textContent });
        const ref = document.head.getElementsByTagName('style')[0] || null;
        document.head.insertBefore(style, ref);
      },
      script: { type: 'module' }
    }

    const Grid = await loadModule('./components/Grid.vue', options)
    const Home = await loadModule('./components/Home.vue', options)
    const Game = await loadModule('./components/Game.vue', options)
    const Settings = await loadModule('./components/Settings.vue', options)
    const Profile = await loadModule('./components/Profile.vue', options)
    const Login = await loadModule('./components/Login.vue', options)
    const Popup = await loadModule('./components/Popup.vue', options)

    const App = {
      components: { Grid, Home, Game, Settings, Profile, Login, Popup },
      setup() {
        const view = Vue.ref('home')
        const userId = Vue.ref(localStorage.getItem('userId'))
        const ongoingGames = Vue.ref([])
        const finishedGames = Vue.ref([])
        const rack = Vue.ref([])
        const placements = Vue.ref([])
        const wordValid = Vue.ref(false)
        const result = Vue.ref('')
        const currentWord = Vue.ref('')
        const userName = Vue.ref('')
        const opponentName = Vue.ref('')
        const score = Vue.ref(0)
        const score_adversaire = Vue.ref(0)
        const userAvatar = Vue.ref('')
        const opponentAvatar = Vue.ref('')
        const gameRef = Vue.ref(null)
        const currentGame = Vue.ref(null)
        const popup = Vue.ref(null)

        function alertApp(message) {
          return new Promise(resolve => {
            popup.value = { type: 'alert', message, resolve }
          })
        }

        function confirmApp(message) {
          return new Promise(resolve => {
            popup.value = { type: 'confirm', message, resolve }
          })
        }

        function promptApp(message) {
          return new Promise(resolve => {
            popup.value = { type: 'prompt', message, value: '', resolve }
          })
        }

        function onPopupConfirm(value) {
          if (popup.value) {
            const { resolve, type } = popup.value
            resolve(type === 'prompt' ? value : true)
            popup.value = null
          }
        }

        function onPopupCancel() {
          if (popup.value) {
            const { resolve, type } = popup.value
            resolve(type === 'prompt' ? null : false)
            popup.value = null
          }
        }

        window.appAlert = alertApp
        window.appConfirm = confirmApp
        window.appPrompt = promptApp

        async function validateWord() {
          const words = collectWords(gameRef.value.getTile, placements.value)
          if (words.length === 0) {
            wordValid.value = false
            currentWord.value = ''
            return
          }

          currentWord.value = words[0]

          try {
            const results = await Promise.all(
              words.map(w =>
                fetch(`${API_BASE}/validate?word=${encodeURIComponent(w)}`)
                  .then(r => r.json())
                  .then(d => d.valid)
              )
            )
            wordValid.value = results.every(Boolean)
          } catch {
            wordValid.value = false
          }
        }

        Vue.watch(placements, validateWord, { deep: true })

        async function loadGames() {
          if (!userId.value) return
          const res = await fetch(`${API_BASE}/games?user_id=${userId.value}`)
          const data = await res.json()
          ongoingGames.value = data.ongoing
          finishedGames.value = data.finished
        }

        async function checkAuth() {
          try {
            console.log(import.meta.env);
            console.log(API_BASE);
            const res = await fetch(`${API_BASE}/auth/me`, { credentials: 'include' })
            if (res.ok) {
              const data = await res.json()
              userId.value = data.user_id
              localStorage.setItem('userId', data.user_id)
              document.documentElement.setAttribute('data-theme', data.color_palette || 'palette1')
              userAvatar.value = data.avatar_url
              startAuthHeartbeat()
              loadGames()
            } else {
              userId.value = null
              localStorage.removeItem('userId')
            }
          } catch (err) {
            // ignore
          }
        }

        async function onAuth(id) {
          userId.value = id
          localStorage.setItem('userId', id)
          view.value = 'home'
          await checkAuth()
        }

        async function logout() {
          try {
            await fetch(`${API_BASE}/auth/logout`, {
              method: 'POST',
              credentials: 'include'
            })
          } catch (err) {
            // ignore
          }
          stopAuthHeartbeat()
          localStorage.removeItem('userId')
          userId.value = null
          ongoingGames.value = []
          finishedGames.value = []
          view.value = 'home'
        }

        async function newGameBot() {
          const resGame = await fetch(`${API_BASE}/games`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ vs_computer: true })
          })
          const { game_id } = await resGame.json()
          const joinRes = await fetch(`${API_BASE}/games/${game_id}/join`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_id: Number(userId.value) })
          })
          const { player_id } = await joinRes.json()
          await fetch(`${API_BASE}/games/${game_id}/join`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ is_computer: true })
          })
          const startRes = await fetch(`${API_BASE}/games/${game_id}/start`, {
            method: 'POST'
          })
          const startData = await startRes.json()
          const info = startData.players.find(p => p.player_id === player_id)
          rack.value = info.rack
          placements.value = []
          result.value = ''
          score.value = 0
          score_adversaire.value = 0
          opponentAvatar.value = '/img/icone/avatars/robot.svg'
          userName.value = userName.value
          opponentName.value = 'Bot'
          const game = { id: game_id, player_id, vsBot: true }
          ongoingGames.value.push(game)
          currentGame.value = game
          view.value = 'game'
        }

        async function newGameFriend(pseudo) {
          const resUser = await fetch(`${API_BASE}/users/by-username?username=${encodeURIComponent(pseudo)}`)
          if (!resUser.ok) {
            await alertApp('Utilisateur introuvable')
            return
          }
          const { user_id: friendId } = await resUser.json()
          const resAvatar = await fetch(`${API_BASE}/users/${friendId}`)
          const friendData = await resAvatar.json()
          opponentAvatar.value = friendData.avatar_url
          const resGame = await fetch(`${API_BASE}/games`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
          })
          const { game_id } = await resGame.json()
          const join1 = await fetch(`${API_BASE}/games/${game_id}/join`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_id: Number(userId.value) })
          })
          const { player_id } = await join1.json()
          await fetch(`${API_BASE}/games/${game_id}/join`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_id: friendId })
          })
          const startRes = await fetch(`${API_BASE}/games/${game_id}/start`, {
            method: 'POST'
          })
          const startData = await startRes.json()
          const info = startData.players.find(p => p.player_id === player_id)
          rack.value = info.rack
          placements.value = []
          result.value = ''
          score.value = 0
          score_adversaire.value = 0
          const game = { id: game_id, player_id, vsBot: false }
          ongoingGames.value.push(game)
          currentGame.value = game
          view.value = 'game'
        }

        async function resumeGame(game) {
          currentGame.value = game
          view.value = 'game'
          await Vue.nextTick()
          const res = await fetch(`${API_BASE}/games/${game.id}?player_id=${game.player_id}`)
          const data = await res.json()

          rack.value = data.rack
          placements.value = []
          result.value = ''
          score.value = data.scores[game.player_id] || 0
          const adversaryId = Number(Object.keys(data.scores).find(id => Number(id) !== game.player_id))
          score_adversaire.value = adversaryId ? data.scores[adversaryId] : 0
          userName.value = data.players.find(p => p.player_id === game.player_id).display_name
          opponentName.value = data.players.find(p => p.player_id !== game.player_id).display_name
          const opp = data.players?.find(p => p.player_id !== game.player_id)
          if (opp) {
            opponentAvatar.value = opp.is_computer ? '/img/icone/avatars/robot.svg' : opp.avatar_url
          }

          view.value = 'game'
          await Vue.nextTick() // assure que <Game> et <Grid> sont montés

          // ✅ API propre exposée par Game.vue
          data.tiles.forEach(t => gameRef.value.setTile(t.row, t.col, t.letter))
        }

        async function finishGame() {
          if (currentGame.value) {
            await fetch(`${API_BASE}/finish`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ game_id: currentGame.value.id })
            })
            const idx = ongoingGames.value.findIndex(g => g.id === currentGame.value.id)
            if (idx !== -1) ongoingGames.value.splice(idx, 1)
            finishedGames.value.push(currentGame.value)
            currentGame.value = null
          }
          view.value = 'home'
        }

        function goHome() {
          view.value = 'home'
        }

        function onDragStart(e, idx) {
          e.dataTransfer.setData('text/plain', JSON.stringify({ letter: rack.value[idx], index: idx, source: 'rack' }))
        }

        function onRackDrop(e, idx) {
          const data = JSON.parse(e.dataTransfer.getData('text/plain'))
          if (data.source === 'rack') {
            const from = data.index
            const tile = rack.value.splice(from, 1)[0]
            const insert = from < idx ? idx - 1 : idx
            rack.value.splice(insert, 0, tile)
          } else if (data.source === 'board') {
            const letter = gameRef.value.gridRef.value.takeBack(data.row, data.col)
            if (!letter) return
            const placementIdx = placements.value.findIndex(p => p.row === data.row && p.col === data.col)
            if (placementIdx !== -1) placements.value.splice(placementIdx, 1)
            rack.value.splice(idx, 0, letter === letter.toLowerCase() ? '?' : letter)
          }
        }

        async function placed(payload) {
          rack.value.splice(payload.index, 1)
          if (payload.letter === '?') {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            let choice = await promptApp(`Choisissez une lettre pour le joker:\n${letters}`)
            if (!choice) {
              rack.value.splice(payload.index, 0, '?')
              gameRef.value.gridRef.value.takeBack(payload.row, payload.col)
              return
            }
            choice = choice.toUpperCase()
            if (!letters.includes(choice)) {
              rack.value.splice(payload.index, 0, '?')
              gameRef.value.gridRef.value.takeBack(payload.row, payload.col)
              return
            }
            gameRef.value.setTile(payload.row, payload.col, choice.toLowerCase(), false)
            placements.value.push({ row: payload.row, col: payload.col, letter: choice, blank: true })
          } else {
            placements.value.push({ row: payload.row, col: payload.col, letter: payload.letter, blank: false })
          }
        }

        function removed(payload) {
          const { row, col, letter } = payload
          const i = placements.value.findIndex(p => p.row === row && p.col === col)
          if (i !== -1) placements.value.splice(i, 1)
          rack.value.push(letter === letter.toLowerCase() ? '?' : letter)
        }

        function moved(payload) {
          const { from, to } = payload
          const i = placements.value.findIndex(p => p.row === from.row && p.col === from.col)
          if (i !== -1) {
            placements.value[i].row = to.row
            placements.value[i].col = to.col
          }
        }

        function clearMove() {
          gameRef.value.clearAll(placements.value)
          placements.value.forEach(p => rack.value.push(p.blank ? '?' : p.letter))
          placements.value = []
        }

        function shuffleRack() {
          for (let i = rack.value.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1))
              ;[rack.value[i], rack.value[j]] = [rack.value[j], rack.value[i]]
          }
        }

        async function play() {
          if (placements.value.length === 0) return
          const execute = async () => {
            const res = await fetch(
              `${API_BASE}/games/${currentGame.value.id}/play`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  player_id: currentGame.value.player_id,
                  placements: placements.value
                })
              }
            )
            if (!res.ok) {
              const err = await res.json()
              const words = await showInvalidWords(alertApp, err.detail, currentWord.value)
              if (!words.length) {
                await alertApp(err.detail || 'Coup invalide')
              }
              result.value = err.detail || 'Coup invalide'
              return
            }
            const data = await res.json()
            if (data.words && data.words.length) {
              await alertApp(data.words.map(w => `${w.word} : ${w.score} pts`).join('\n'))
            }
            result.value = `Score : ${data.score}`
            gameRef.value.lockTiles(placements.value)
            placements.value = []
            if (data.bot_move) {
              data.bot_move.forEach(([row, col, letter, blank]) => {
                gameRef.value.setTile(row, col, blank ? letter.toLowerCase() : letter)
              })
            }
            const stateRes = await fetch(
              `${API_BASE}/games/${currentGame.value.id}?player_id=${currentGame.value.player_id}`
            )
            const stateData = await stateRes.json()
            rack.value = stateData.rack
            score.value = stateData.scores[currentGame.value.player_id] || 0
            const advId = Number(Object.keys(stateData.scores).find(id => Number(id) !== currentGame.value.player_id))
            score_adversaire.value = advId ? stateData.scores[advId] : 0
            const opp = stateData.players?.find(p => p.player_id !== currentGame.value.player_id)
            if (opp) {
              opponentAvatar.value = opp.is_computer ? '/img/icone/avatars/robot.svg' : opp.avatar_url
            }
          }
          if (currentGame.value?.vsBot) {
            await runBotThinking(popup, execute)
          } else {
            await execute()
          }
        }

        async function passTurn() {
          clearMove()
          const execute = async () => {
            const res = await fetch(
              `${API_BASE}/games/${currentGame.value.id}/pass`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ player_id: currentGame.value.player_id })
              }
            )
            if (!res.ok) {
              const err = await res.json()
              result.value = err.detail || 'Action impossible'
              return
            }
            const data = await res.json()
            result.value = 'Tour passé'
            if (data.bot_move) {
              data.bot_move.forEach(([row, col, letter, blank]) => {
                gameRef.value.setTile(row, col, blank ? letter.toLowerCase() : letter)
              })
            }
            const stateRes = await fetch(
              `${API_BASE}/games/${currentGame.value.id}?player_id=${currentGame.value.player_id}`
            )
            const stateData = await stateRes.json()
            rack.value = stateData.rack
            score.value = stateData.scores[currentGame.value.player_id] || 0
            const advId = Number(Object.keys(stateData.scores).find(id => Number(id) !== currentGame.value.player_id))
            score_adversaire.value = advId ? stateData.scores[advId] : 0
            const opp = stateData.players?.find(p => p.player_id !== currentGame.value.player_id)
            if (opp) {
              opponentAvatar.value = opp.is_computer ? '/img/icone/avatars/robot.svg' : opp.avatar_url
            }
          }
          if (currentGame.value?.vsBot) {
            await runBotThinking(popup, execute)
          } else {
            await execute()
          }
        }

        checkAuth()

        return {
          view,
          userId,
          ongoingGames,
          finishedGames,
          newGameFriend,
          newGameBot,
          resumeGame,
          finishGame,
          goHome,
          rack,
          onDragStart,
          placed,
          play,
          result,
          LETTER_POINTS,
          onRackDrop,
          gameRef,
          removed,
          clearMove,
          shuffleRack,
          passTurn,
          moved,
          onAuth,
          logout,
          score,
          score_adversaire,
          userAvatar,
          opponentAvatar,
          wordValid,
          popup,
          onPopupConfirm,
          onPopupCancel
        }
      },
      template: `
        <Login v-if="!userId" @auth="onAuth" />
        <Home v-else-if="view==='home'"
              :ongoing-games="ongoingGames"
              :finished-games="finishedGames"
              @new-game-friend="newGameFriend"
              @new-game-bot="newGameBot"
              @resume="resumeGame"
              @navigate="view=$event" />
          <Game v-else-if="view==='game'"
                ref="gameRef"
                :rack="rack"
                :result="result"
                :score="score"
                :score_adversaire="score_adversaire"
                :player-avatar="userAvatar"
                :opponent-avatar="opponentAvatar"
                :letter-points="LETTER_POINTS"
                :word-valid="wordValid"
                @home="goHome"
                @finish="finishGame"
                @placed="placed"
                @removed="removed"
                @moved="moved"
                @rack-drop="onRackDrop"
                @drag-start="onDragStart"
                @play="play"
                @clear="clearMove"
                @shuffle="shuffleRack"
                @pass="passTurn" />
          <Profile v-else-if="view==='profile'" @back="view='home'" @logout="logout" />
          <Settings v-else-if="view==='settings'" @back="view='home'" />
          <Popup v-if="popup" :popup="popup" @confirm="onPopupConfirm" @cancel="onPopupCancel" />
        `
    }

    const app = Vue.createApp(App)
    app.component('Grid', Grid)
    app.mount('#app')  </script>
</body>

</html>